#!/usr/bin/env python3
"""
vulnerability_analysis.py

VS Code / local-friendly script to compute "vulnerability to automation"
from a CSV (or use built-in sample). Produces console output, displays charts,
and writes a results CSV.

Usage:
    python vulnerability_analysis.py                 # runs example dataset
    python vulnerability_analysis.py --csv data.csv   # uses your CSV
    python vulnerability_analysis.py --csv data.csv --save-plots --output results.csv
"""

import argparse
import sys
import os
import math

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import MinMaxScaler

sns.set(style="whitegrid")  # seaborn styling

EXPECTED_COLUMNS = {
    "occupation",
    "sector",
    "region",
    "percent_low_skill",
    "automation_score",
    "workers_count",
}


def load_dataset(csv_path: str = None) -> pd.DataFrame:
    """Load dataset from CSV if provided; otherwise create a synthetic sample."""
    if csv_path:
        if not os.path.isfile(csv_path):
            raise FileNotFoundError(f"CSV file not found: {csv_path}")
        df = pd.read_csv(csv_path)
        print(f"Loaded CSV: {csv_path} — {len(df)} rows")
        return df
    else:
        # synthetic sample dataset (for demo)
        occupations = [
            "Cashier", "Assembly Worker", "Data Entry Clerk", "Truck Driver",
            "Software Dev", "Healthcare Asst", "Teacher (primary)", "Janitor"
        ]
        sectors = [
            "Retail", "Manufacturing", "Admin", "Transport",
            "IT", "Health", "Education", "Services"
        ]
        region = ["Rural", "Urban", "Urban", "Rural", "Urban", "Rural", "Rural", "Urban"]
        automation_score = [0.75, 0.65, 0.80, 0.45, 0.15, 0.30, 0.10, 0.60]
        percent_low_skill = [0.9, 0.85, 0.95, 0.7, 0.2, 0.6, 0.1, 0.92]
        workers_count = [120000, 90000, 50000, 80000, 150000, 70000, 60000, 40000]
        df = pd.DataFrame({
            "occupation": occupations,
            "sector": sectors,
            "region": region,
            "percent_low_skill": percent_low_skill,
            "automation_score": automation_score,
            "workers_count": workers_count
        })
        print("Using synthetic demo dataset")
        return df


def validate_and_prepare(df: pd.DataFrame) -> pd.DataFrame:
    """Ensure required columns exist and coerce types where reasonable."""
    # Lowercase column names for robustness
    df = df.rename(columns={c: c.strip() for c in df.columns})
    cols = set(df.columns)

    missing = EXPECTED_COLUMNS - set(map(str.lower, map(str, cols)))
    # Try case-insensitive matching for expected columns
    if missing:
        # map to lower for matching
        lower_map = {c.lower(): c for c in df.columns}
        remedied = {}
        for needed in EXPECTED_COLUMNS:
            ln = needed.lower()
            if ln in lower_map:
                remedied[needed] = lower_map[ln]
        # If remedied covers all expected, rename
        if set(remedied.keys()) == EXPECTED_COLUMNS:
            df = df.rename(columns={v: k for k, v in remedied.items()})
        else:
            # If still missing, warn but continue if key numeric columns present
            print("Warning: CSV doesn't contain all expected columns.")
            print("Expected columns (ideal):", EXPECTED_COLUMNS)
            print("Found columns:", set(df.columns))
            # We'll attempt to continue — ensure at least autom. score & workers_count exist
            # If crucial columns missing, stop:
            required_numeric = {"automation_score", "workers_count", "percent_low_skill"}
            if not required_numeric.issubset(set(map(str.lower, map(str, df.columns)))):
                raise ValueError(f"CSV lacks required numeric columns: {required_numeric}")

    # Coerce numeric columns
    for col in ["automation_score", "percent_low_skill", "workers_count"]:
        if col in df.columns:
            # Remove commas, spaces before conversion if strings exist
            df[col] = df[col].astype(str).str.replace(",", "").str.strip()
            df[col] = pd.to_numeric(df[col], errors="coerce")
        else:
            # if missing, fill defaults
            if col == "automation_score":
                df[col] = 0.0
            elif col == "percent_low_skill":
                df[col] = 0.0
            elif col == "workers_count":
                df[col] = 0.0

    # Fill NaNs with sensible defaults (0)
    df["automation_score"] = df["automation_score"].fillna(0.0)
    df["percent_low_skill"] = df["percent_low_skill"].fillna(0.0)
    df["workers_count"] = df["workers_count"].fillna(0.0)

    # Ensure percent_low_skill is in 0-1 range if given as percentage (0-100)
    # If max > 1.5 assume percent format
    if df["percent_low_skill"].max() > 1.5:
        df["percent_low_skill"] = df["percent_low_skill"] / 100.0

    return df


def compute_vulnerability(df: pd.DataFrame) -> pd.DataFrame:
    """Compute vulnerability score and return sorted df."""
    df = df.copy()
    # Use log1p to avoid log(0)
    df["vuln_raw"] = df["automation_score"] * df["percent_low_skill"] * np.log1p(df["workers_count"])
    scaler = MinMaxScaler()
    df["vulnerability"] = scaler.fit_transform(df[["vuln_raw"]])
    df = df.sort_values("vulnerability", ascending=False).reset_index(drop=True)
    return df


def plot_vulnerability_by_occupation(df: pd.DataFrame, save_path: str = None):
    plt.figure(figsize=(10, max(4, 0.6 * len(df))))
    ax = sns.barplot(data=df, x="vulnerability", y="occupation", palette="viridis")
    ax.set_title("Vulnerability to Automation (0-1 scaled)")
    ax.set_xlabel("Vulnerability")
    plt.tight_layout()
    if save_path:
        plt.savefig(save_path, dpi=300)
        print(f"Saved plot: {save_path}")
    plt.show()
    plt.close()


def plot_avg_vulnerability_by_region(df: pd.DataFrame, save_path: str = None):
    agg_region = df.groupby("region").apply(lambda g: pd.Series({
        "avg_vulnerability": g["vulnerability"].mean(),
        "exposed_workers": (g["vulnerability"] * g["workers_count"]).sum()
    })).reset_index()
    print("\nAggregated by region:")
    print(agg_region)
    plt.figure(figsize=(8, 4))
    sns.barplot(data=agg_region, x="region", y="avg_vulnerability")
    plt.title("Average Vulnerability by Region")
    plt.tight_layout()
    if save_path:
        plt.savefig(save_path, dpi=300)
        print(f"Saved plot: {save_path}")
    plt.show()
    plt.close()
    return agg_region


def main(args):
    try:
        df = load_dataset(args.csv)
        df = validate_and_prepare(df)
        print("\nDataset preview:")
        print(df.head().to_string(index=False))

        df = compute_vulnerability(df)
        print("\nTop vulnerable occupations:")
        print(df[["occupation", "sector", "region", "automation_score", "percent_low_skill", "workers_count", "vulnerability"]].head(10).to_string(index=False))

        # Plot vulnerability by occupation
        plot_vulnerability_by_occupation(df, save_path=("vulnerability_by_occupation.png" if args.save_plots else None))

        # Aggregate and plot by region
        agg_region = plot_avg_vulnerability_by_region(df, save_path=("vulnerability_by_region.png" if args.save_plots else None))

        # Save results
        out_csv = args.output or "vulnerability_results.csv"
        df.to_csv(out_csv, index=False)
        print(f"\nSaved results to {out_csv}")

        # Also save aggregated region table if requested
        if args.save_plots:
            agg_region.to_csv("agg_region.csv", index=False)
            print("Saved aggregated region table to agg_region.csv")

    except Exception as e:
        print("Error:", e)
        sys.exit(1)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Compute vulnerability to automation from a CSV or demo data.")
    parser.add_argument("--csv", type=str, help="Path to input CSV file (optional).")
    parser.add_argument("--save-plots", action="store_true", help="Save plots as PNG files.")
    parser.add_argument("--output", type=str, help="Output CSV filename (default: vulnerability_results.csv).")
    args = parser.parse_args()
    main(args)